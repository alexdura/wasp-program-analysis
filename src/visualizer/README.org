#+TITLE: The graph visualizer VERSION 2

Because emacs somehow wrote the wrong buffer in the previous version.

* What is this

This is a script that will take a ~results.json~ file as an input, and output a dot file.

Here is how to use the script: 
#+BEGIN_SRC bash
python results_visualizer.py results.json # Generates a dot file
dot -Tpdf results.dot # Generates a PDF for you.
#+END_SRC

* How does it work?

First, it loads JSON from the results.json file, if provided.

#+NAME: load_json
#+BEGIN_SRC python
import json
import sys
import re # For regular expressions.

if sys.argv[0]:
    filename = sys.argv[0]
else:
    filename = "results.json"

f = open(filename)
json_data = json.load(f)
#+END_SRC

#+RESULTS: load_json
: None

#+BEGIN_SRC python :results output :noweb yes
<<load_json>>
print("JSON_DATA", json_data)
#+END_SRC

#+RESULTS:
: ('JSON_DATA', [{u'DataFlow': {u'main::%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM']]}, u'main::store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3': {u'Facts': [[u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM']]}, u'main::%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%4 = load i32, i32* %2, align 4, !phasar.instruction.id !7, ID: 5': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::ret i32 %5, !phasar.instruction.id !10, ID: 8': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::store i32 0, i32* %2, align 4, !phasar.instruction.id !6, ID: 4': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::store i32 %4, i32* %3, align 4, !phasar.instruction.id !8, ID: 6': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%5 = load i32, i32* %3, align 4, !phasar.instruction.id !9, ID: 7': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}}}])

Then we extract the data from it, we are interested in the ~DataFlow~ data.

#+NAME: load_dataflow
#+BEGIN_SRC python :noweb yes
<<load_json>>
dataflow_data = [d for d in json_data if d["DataFlow"]][0]["DataFlow"]
#+END_SRC

#+RESULTS: load_dataflow
: None

We can test our function:

#+BEGIN_SRC python :results output :noweb yes
<<load_dataflow>>
print("DATAFLOW_DATA", dataflow_data)
#+END_SRC

#+RESULTS:
: ('DATAFLOW_DATA', {u'main::%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM']]}, u'main::store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3': {u'Facts': [[u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM']]}, u'main::%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%4 = load i32, i32* %2, align 4, !phasar.instruction.id !7, ID: 5': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::ret i32 %5, !phasar.instruction.id !10, ID: 8': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::store i32 0, i32* %2, align 4, !phasar.instruction.id !6, ID: 4': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::store i32 %4, i32* %3, align 4, !phasar.instruction.id !8, ID: 6': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%5 = load i32, i32* %3, align 4, !phasar.instruction.id !9, ID: 7': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}})

* Graphviz syntax

We want to convert the content of our graph to graphviz.

Here is the syntax for a graph in graphviz:

#+BEGIN_SRC dot
// The graph name and the semicolons are optional
graph graphname {
    a -- b -- c;
    b -- d;
}
#+END_SRC

For that we create a Python function that creates a graph, based on how we told it to create edges and vertice data.

#+NAME:make_graph
#+BEGIN_SRC python :noweb yes
  <<make_vertices>> 
  <<make_edges>>
  def make_graph(dataflow_data):
      return 'graph DataFlow {{\n{vertices}\n{edges}}}'.format(
	  vertices=make_vertices(dataflow_data),
	  edges=make_edges(dataflow_data))
#+END_SRC

#+RESULTS: make_graph

We can test the function on our data-flow-data program:
#+NAME:make_graph_test
#+BEGIN_SRC python :noweb yes :results output
# Loading the dataflow data
<<load_dataflow>>
# Getting the make_graph function and its friends
<<make_graph>>
print(make_graph(dataflow_data))
#+END_SRC

#+RESULTS: make_graph_test
#+begin_example
('JSON_DATA', [{u'DataFlow': {u'main::%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM']]}, u'main::store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3': {u'Facts': [[u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM']]}, u'main::%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%4 = load i32, i32* %2, align 4, !phasar.instruction.id !7, ID: 5': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::ret i32 %5, !phasar.instruction.id !10, ID: 8': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::store i32 0, i32* %2, align 4, !phasar.instruction.id !6, ID: 4': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::store i32 %4, i32* %3, align 4, !phasar.instruction.id !8, ID: 6': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%5 = load i32, i32* %3, align 4, !phasar.instruction.id !9, ID: 7': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}}}])
('DATAFLOW_DATA', {u'main::%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM']]}, u'main::store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3': {u'Facts': [[u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM']]}, u'main::%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%4 = load i32, i32* %2, align 4, !phasar.instruction.id !7, ID: 5': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::ret i32 %5, !phasar.instruction.id !10, ID: 8': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::store i32 0, i32* %2, align 4, !phasar.instruction.id !6, ID: 4': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::store i32 %4, i32* %3, align 4, !phasar.instruction.id !8, ID: 6': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%5 = load i32, i32* %3, align 4, !phasar.instruction.id !9, ID: 7': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}})
graph DataFlow {

"%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2"
"store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3"
"%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0"
"%4 = load i32, i32* %2, align 4, !phasar.instruction.id !7, ID: 5"
"ret i32 %5, !phasar.instruction.id !10, ID: 8"
"store i32 0, i32* %2, align 4, !phasar.instruction.id !6, ID: 4"
"store i32 %4, i32* %3, align 4, !phasar.instruction.id !8, ID: 6"
"%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1"
"%5 = load i32, i32* %3, align 4, !phasar.instruction.id !9, ID: 7"
"%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2" -- "%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0";
"%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2" -- "@zero_value = constant i2 0, align 4, ID: -1";
"%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2" -- "%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1";
"store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3" -- "%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1";
"store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3" -- "%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2";
"store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3" -- "@zero_value = constant i2 0, align 4, ID: -1";
"store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3" -- "%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0";
"%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0" -- "@zero_value = constant i2 0, align 4, ID: -1";
"%4 = load i32, i32* %2, align 4, !phasar.instruction.id !7, ID: 5" -- "@zero_value = constant i2 0, align 4, ID: -1";
"%4 = load i32, i32* %2, align 4, !phasar.instruction.id !7, ID: 5" -- "%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2";
"ret i32 %5, !phasar.instruction.id !10, ID: 8" -- "@zero_value = constant i2 0, align 4, ID: -1";
"store i32 0, i32* %2, align 4, !phasar.instruction.id !6, ID: 4" -- "@zero_value = constant i2 0, align 4, ID: -1";
"store i32 0, i32* %2, align 4, !phasar.instruction.id !6, ID: 4" -- "%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1";
"store i32 0, i32* %2, align 4, !phasar.instruction.id !6, ID: 4" -- "%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2";
"store i32 %4, i32* %3, align 4, !phasar.instruction.id !8, ID: 6" -- "@zero_value = constant i2 0, align 4, ID: -1";
"store i32 %4, i32* %3, align 4, !phasar.instruction.id !8, ID: 6" -- "%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2";
"%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1" -- "%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0";
"%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1" -- "@zero_value = constant i2 0, align 4, ID: -1";
"%5 = load i32, i32* %3, align 4, !phasar.instruction.id !9, ID: 7" -- "@zero_value = constant i2 0, align 4, ID: -1";
}
#+end_example

* Writing to a file
  
Now that we have our function, we can write to a file:

#+BEGIN_SRC python :noweb yes
  <<load_dataflow>>
  <<make_graph>>
  with open("results.dot", 'w') as output_file:
      text = make_graph(dataflow_data)
      output_file.write(text)
#+END_SRC

#+RESULTS:
: None

** Making vertices
   
I want something that makes vertice data. It should look like:

#+BEGIN_SRC
<id> [label="<label>"]
<id2> [label="<label2>"]
...
#+END_SRC

This is how we make it in Python

#+NAME: make_vertices
#+BEGIN_SRC python :noweb yes
  def make_vertex(vertex_name):
      """
      A function that will return the vertex name between quotation marks
      """
      # The result sometimes has the name
      # of the method as a prefix
      if (re.match("[a-zA-Z]+::", vertex_name)):
	  # we return the suffix only
	  return "\"{0}\"".format(
	      vertex_name.split("::")[1])
      else:
	  return "\"{0}\"".format(vertex_name)

  def make_vertices(dataflow_data):
      """A function that will create vertex labels"""
      text = ""
      for v in dataflow_data:
	  text += "\n"
	  text += make_vertex(v)

      return text
#+END_SRC

#+RESULTS: make_vertices
: None

** Making edges

We want something that looks like: 

#+BEGIN_SRC 
<vertex1> -- <vertex2>
<vertex1> -- <vertex3>
...
#+END_SRC

This is how we write it in Python

#+NAME: make_edges
#+BEGIN_SRC python :results output :noweb yes
  <<make_vertices>>
  def make_edges(dataflow_data):
      """ A function that will create the string for edges spec"""
      text = ""
      for (vertex, info) in dataflow_data.items():
	  facts = info["Facts"]
	  targets = [f[0] for f in facts]
	  for target in targets:
	      line = "{0} -- {1};".format(
		  make_vertex(vertex),
		  make_vertex(target))
	      text += line + "\n"

      return text
#+END_SRC

We can test the function: 

#+BEGIN_SRC python :results output :noweb yes
  import re
  <<make_edges>>
  # A test
  print(make_edges({"v1" : {"Facts" : [["v2", "BOTTOM"], ["zero", "BOTTOM"]]}}))
#+END_SRC

#+RESULTS:
: "v1" -- "v2";
: "v1" -- "zero";
: 

As expected.
