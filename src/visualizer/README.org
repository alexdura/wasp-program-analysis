#+TITLE: The graph visualizer VERSION 2

Because emacs somehow wrote the wrong buffer in the previous version.

* What is this

This is a script that will take a ~results.json~ file as an input, and output a ~results.dot~ file.

Here is how to use the script:
#+BEGIN_SRC bash
python results_visualizer.py results.json # Generates a dot file
dot -Tpdf results.dot # Generates a PDF for you.
#+END_SRC

* How does it work?

First, it loads JSON from the results.json file, if provided.

#+NAME: imports
#+BEGIN_SRC python
import json
import sys
import re # For regular expressions.
#+END_SRC


#+NAME: load_json
#+BEGIN_SRC python
if len(sys.argv) != 1:
    filename = sys.argv[1]
else:
    filename = "results.json"

print("Loading from '{0}'...'".format(filename))

f = open(filename)
json_data = json.load(f)
#+END_SRC

#+RESULTS: load_json
: None

#+BEGIN_SRC python :results output :noweb yes :exports both
<<imports>>
<<load_json>>
print("JSON_DATA", json_data)
#+END_SRC

#+RESULTS:
: ('JSON_DATA', [{u'DataFlow': {u'main::%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM']]}, u'main::store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3': {u'Facts': [[u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM']]}, u'main::%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%4 = load i32, i32* %2, align 4, !phasar.instruction.id !7, ID: 5': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::ret i32 %5, !phasar.instruction.id !10, ID: 8': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::store i32 0, i32* %2, align 4, !phasar.instruction.id !6, ID: 4': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::store i32 %4, i32* %3, align 4, !phasar.instruction.id !8, ID: 6': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%5 = load i32, i32* %3, align 4, !phasar.instruction.id !9, ID: 7': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}}}])

Then we extract the data from it, we are interested in the ~DataFlow~ data.

#+NAME: load_dataflow
#+BEGIN_SRC python :noweb yes
<<load_json>>
dataflow_data = [d for d in json_data if d["DataFlow"]][0]["DataFlow"]
#+END_SRC

#+RESULTS: load_dataflow
: None

We can test our function:

#+BEGIN_SRC python :results output :noweb yes :exports both
<<load_dataflow>>
print("DATAFLOW_DATA", dataflow_data)
#+END_SRC

#+RESULTS:
: ('DATAFLOW_DATA', {u'main::%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM']]}, u'main::store i32 0, i32* %1, align 4, !phasar.instruction.id !5, ID: 3': {u'Facts': [[u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM']]}, u'main::%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%4 = load i32, i32* %2, align 4, !phasar.instruction.id !7, ID: 5': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::ret i32 %5, !phasar.instruction.id !10, ID: 8': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::store i32 0, i32* %2, align 4, !phasar.instruction.id !6, ID: 4': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::store i32 %4, i32* %3, align 4, !phasar.instruction.id !8, ID: 6': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM'], [u'%3 = alloca i32, align 4, !phasar.instruction.id !4, ID: 2', u'BOTTOM']]}, u'main::%2 = alloca i32, align 4, !phasar.instruction.id !3, ID: 1': {u'Facts': [[u'%1 = alloca i32, align 4, !phasar.instruction.id !2, ID: 0', u'BOTTOM'], [u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}, u'main::%5 = load i32, i32* %3, align 4, !phasar.instruction.id !9, ID: 7': {u'Facts': [[u'@zero_value = constant i2 0, align 4, ID: -1', u'BOTTOM']]}})

** Generating graphviz

 We want to convert the content of our graph to graphviz.

 Here is the syntax for a graph in graphviz:

 #+BEGIN_SRC dot
// The graph name and the semicolons are optional
graph graphname {
    a -- b -- c;
    b -- d;
}
 #+END_SRC

 For that we create a Python function that creates a graph, based on how we told it to create edges and vertice data.

 #+NAME:make_graph
 #+BEGIN_SRC python :noweb yes
<<make_vertices>>
<<make_edges>>
def make_graph(dataflow_data):
    return 'graph DataFlow {{\n{vertices}\n{edges}}}'.format(
        vertices=make_vertices(dataflow_data),
        edges=make_edges(dataflow_data))


 #+END_SRC

 #+RESULTS: make_graph

 We can test the function on our data-flow-data program:
 #+NAME:make_graph_test
 #+BEGIN_SRC python :noweb yes :results output :exports both
<<imports>>
# Loading the dataflow data
<<load_dataflow>>
# Getting the make_graph function and its friends
<<make_graph>>
print(make_graph(dataflow_data))
 #+END_SRC

 #+RESULTS: make_graph_test
 #+begin_example
 Loading from 'results.json'...'
 graph DataFlow {

 ID_2 [label="%3 = alloca i32, align 4, !pha"]
 ID_3 [label="store i32 0, i32* %1, align 4,"]
 ID_0 [label="%1 = alloca i32, align 4, !pha"]
 ID_5 [label="%4 = load i32, i32* %2, align "]
 ID_8 [label="ret i32 %5, !phasar.instructio"]
 ID_4 [label="store i32 0, i32* %2, align 4,"]
 ID_6 [label="store i32 %4, i32* %3, align 4"]
 ID_1 [label="%2 = alloca i32, align 4, !pha"]
 ID_7 [label="%5 = load i32, i32* %3, align "]
 ID_2 -- ID_0;
 ID_2 -- ZERO;
 ID_2 -- ID_1;
 ID_3 -- ID_1;
 ID_3 -- ID_2;
 ID_3 -- ZERO;
 ID_3 -- ID_0;
 ID_0 -- ZERO;
 ID_5 -- ZERO;
 ID_5 -- ID_2;
 ID_8 -- ZERO;
 ID_4 -- ZERO;
 ID_4 -- ID_1;
 ID_4 -- ID_2;
 ID_6 -- ZERO;
 ID_6 -- ID_2;
 ID_1 -- ID_0;
 ID_1 -- ZERO;
 ID_7 -- ZERO;
 }
 #+end_example

** Writing to a file

 Now that we have our function, we can write to a file:

 #+BEGIN_SRC python :noweb yes :tangle results_visualizer.py
#!/usr/bin/env python
<<imports>>

# Utilities declarations
<<make_graph>>
if __name__ == "__main__":
    <<load_dataflow>>
    with open("results.dot", 'w') as output_file:
        output_text = make_graph(dataflow_data)
        output_file.write(output_text)
 #+END_SRC

 #+RESULTS:
 : None

* Appendix: Printing functions
** Making vertices
I want something that makes vertice data. It should look like:

#+BEGIN_SRC
<id> [label="<label>"]
<id2> [label="<label2>"]
...
#+END_SRC

Since we have fairly long labels, we want to generate simple IDs for them.
The edges will be specified in terms of IDs.

#+NAME: make_vertices
#+BEGIN_SRC python :noweb yes
def make_id(vertex_name):
    """
    Extracts the ID from the label of the vertex, to use it.
    """
    match_z = re.search("ID: -1", vertex_name)
    if match_z:
        return "ZERO"

    match = re.search("ID: ([0-9]+|-1)", vertex_name)
    if match:
        return "ID_" + match.group(1)
    

def make_vertex(vertex_name):
    """
    A function that will return the vertex name between quotation marks
    """
    # The result sometimes has the name
    # of the method as a prefix
    text = ""
    if (re.match("[a-zA-Z]+::", vertex_name)):
        # we return the suffix only
        text = vertex_name.split("::")[1]
    else:
        text = vertex_name

    return text[0:30]


def make_vertices(dataflow_data):
    """A function that will create vertex labels"""
    text = ""
    for v in dataflow_data:
        text += "\n"
        text += make_id(v) + " " + "[label=\"{0}\"]".format(make_vertex(v))

    return text


#+END_SRC

#+RESULTS: make_vertices
: None

We can test the function:
#+BEGIN_SRC python :noweb yes :results output :exports both
<<imports>>
<<make_vertices>>
print(make_id("%1, ID: 0"))
print(make_id("@zero_value, ID: -1"))
#+END_SRC

#+RESULTS:
: ID_0
: ZERO

** Making edges

We want something that looks like:

#+BEGIN_SRC
<vertex1> -- <vertex2>
<vertex1> -- <vertex3>
...
#+END_SRC

This is how we write it in Python

#+NAME: make_edges
#+BEGIN_SRC python :results output :noweb yes
def make_edges(dataflow_data):
    """ A function that will create the string for edges spec"""
    text = ""
    for (vertex, info) in dataflow_data.items():
        facts = info["Facts"]
        targets = [f[0] for f in facts]
        for target in targets:
            line = "{0} -- {1};".format(
                make_id(vertex),
                make_id(target))
            text += line + "\n"

    return text


#+END_SRC

We can test the function:

#+BEGIN_SRC python :results output :noweb yes :exports both
import re
<<make_vertices>>
<<make_edges>>
# A test
print(make_edges({"v1, ID: 1" : {"Facts" : [["v2, ID: 2", "BOTTOM"], ["zero, ID: -1", "BOTTOM"]]}}))
#+END_SRC

#+RESULTS:
: ID_1 -- ID_2;
: ID_1 -- ZERO;
: 
