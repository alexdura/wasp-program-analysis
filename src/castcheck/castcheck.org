#+TITLE: Castcheck, checking types in gObject
#+AUTHOR: Noric Couderc, Alexandru Dura

* Getting started
** Dependencies
   You need:
   - =phasar= within your PATH
   - =json.hpp=
   - probably some other things (please add them to this file!)
** Starting
  To start the analysis on the example file, you need to do:
  #+BEGIN_SRC bash
  make
  #+END_SRC
  The makefile builds and runs the analysis.

* Analysis
  The analysis should be divided into two phases.
  1. Finding the type hierarchy
  2. Checking for invalid type casts

** Finding the type hierarchy
   This analysis tries to infer the type hierarchy from the provided source code.

   Class objects are stored as structs, and their first field is a pointer to the parent class object.
   We need to find two things:
   1. Identify which class objects are created (we want a list of all the class objects in the program)
   2. We want to have access to their parent class pointer field, see where it points to.

   If we get the full points-to graph, we can get this information.
   We don't need the whole points-to graph: any node
   that is pointing to something else than a class object does not really need
   to be considered. We can use this fact for optimizing, when needed.

   Pointers are =llvm::Value= objects.

   For the next sections, we will use code from the =gobject-example=
   file, available in the tests. It does three things:
   1. Create an class dog, and one instance
   2. Calls a method of that class (the bark method)
   3. Destroys the object

*** TODO Finding the class objects
    The =.ll= file contains the following line:
    #+BEGIN_SRC
    =%struct.MyDogClass = type { %struct._GObjectClass }=
    #+END_SRC

    Which seems to indicate that a class type is created
    (but maybe it is only named like that by the user ?)

    It also seems like the struct =MyDogClass= only contains
    one field, of type =_GObjectClass=. If we can extract the type
    of structs, then we will be able to know.
    (Most likely, =llvm::Value= is where we should look).

    We know the class should be created dynamically, therefore,
    we can try to look if there is a =MyDogClass= struct created
    anywhere in the file.

    There is a function =@my_dog_class_intern_init(i8*)=, which
    probably creates this MyDogClass object, since it contains
    a =bitcast= to =%struct.MyDogClass*=:
    #+BEGIN_SRC
    %11 = bitcast i8* %10 to %struct.MyDogClass*, !dbg !210
    #+END_SRC

    So we know that =%11= in this function is a =MyDogClass=.

    Unfortunately, the function returns =void=, so we need
    to model the heap to know who might point to =%11=.

    To do that, we should look at the types of analyses that are
    available.

*** TODO Finding the pointer to their parent class
    The =.ll= file contains the following line:
    #+BEGIN_SRC
    @my_dog_parent_class = internal global i8* null, align 8, !dbg !184
    #+END_SRC

    It seems this pointer always has a name ending in =_parent_class=.

    - =@= seems to indicate that the variable is global.
    - =internal= means the variable is only visible to functions in the file where it is defined
      - similar to =static= in C.

    In our example, this pointer is only part of a store
    instruction in the function =my_dog_class_intern_init(i8*)=,
    here is the beginning of this function (until the store)

    #+BEGIN_SRC
    %2 = alloca i8*, align 8
    store i8* %0, i8** %2, align 8
    call void @llvm.dbg.declare(metadata i8** %2, metadata !209, metadata !DIExpression()), !dbg !210
    %3 = load i8*, i8** %2, align 8, !dbg !210
    %4 = call i8* @g_type_class_peek_parent(i8* %3), !dbg !210
    store i8* %4, i8** @my_dog_parent_class, align 8, !dbg !210
    #+END_SRC

    The function =g_type_class_peek_parent(i8*)= seems to be what we are looking for.
    it will return the pointer to the parent class.

*** Header
    #+BEGIN_SRC c++ :tangle TypeHierarchy.h

    #+END_SRC

*** Implemenatation
    #+BEGIN_SRC c++ :tangle TypeHierarchy.cxx
    #include "TypeHierarchy.h"
    #+END_SRC

** Checking for invalid type casts
   This should be an IFDS analysis.
   First, we need to declare the class =CastCheck= which is a subclass of =IFDSTabulationProblemPlugin=.
   Implementing a plugin requires to implement some flow functions, in the next section.
   First, we need the header file:

*** Header
    Here we define the class =CastCheck=.
    #+BEGIN_SRC c++ :noweb yes :tangle CastCheck.h
      #ifndef CAST_CHECK_H_
      #define CAST_CHECK_H_

      #include <map>
      #include <memory>
      #include <phasar/PhasarLLVM/Plugins/Interfaces/IfdsIde/IFDSTabulationProblemPlugin.h>
      #include <set>
      #include <vector>

      class CastCheck : public psr::IFDSTabulationProblemPlugin {
      std::set<const llvm::Value*> TaintedValues;
      std::map<const llvm::Instruction*, std::set<const llvm::Value*>> LeakMap;

      public:
      // Constructor
      CastCheck(psr::LLVMBasedICFG &I, std::vector<std::string> EntryPoints);
      // Destructor
      ~CastCheck() = default;

      <<flow_functions_header>>

      std::map<const llvm::Instruction *, std::set<const llvm::Value *>>
      initialSeeds() override;

      void printIFDSReport(std::ostream &os,
		      psr::SolverResults<const llvm::Instruction*,
		      const llvm::Value*, psr::BinaryDomain> &SR) override;
      };

      extern "C" std::unique_ptr<psr::IFDSTabulationProblemPlugin>
      makeCastCheck(psr::LLVMBasedICFG &I, std::vector<std::string> EntryPoints);

      #endif
    #+END_SRC

**** Flow functions
     Here, we declare the functions that will return the flow functions.
     #+NAME:flow_functions_header
     #+BEGIN_SRC c++
     std::shared_ptr<psr::FlowFunction<const llvm::Value *>>
     getNormalFlowFunction(const llvm::Instruction *curr,
		     const llvm::Instruction *succ) override;

     std::shared_ptr<psr::FlowFunction<const llvm::Value *>>
     getCallFlowFunction(const llvm::Instruction *callStmt,
		 const llvm::Function *destMthd) override;

     std::shared_ptr<psr::FlowFunction<const llvm::Value *>>
     getRetFlowFunction(const llvm::Instruction *callSite,
		 const llvm::Function *calleeMthd,
		 const llvm::Instruction *exitStmt,
		 const llvm::Instruction *retSite) override;

     std::shared_ptr<psr::FlowFunction<const llvm::Value *>>
     getCallToRetFlowFunction(const llvm::Instruction *callSite,
		     const llvm::Instruction *retSite,
		     std::set<const llvm::Function *> callees) override;

     std::shared_ptr<psr::FlowFunction<const llvm::Value *>>
     getSummaryFlowFunction(const llvm::Instruction *callStmt,
		     const llvm::Function *destMthd) override;
     #+END_SRC

*** TODO Implementation
    The implementation has several parts:
    - Includes
    - Construction, registering and destruction
    - Flow functions
      - Normal flow function
      - Call flow function
      - Return flow function
      - Call to return flow function
      - Summary flow function
    - Initial seeds (What is this?)
    - Printing of report

    This code will be in the subsequent session,
    but for now we set up a squeleton.
    #+BEGIN_SRC c++ :noweb yes :tangle CastCheck.cxx
    #include "CastCheck.h"
    #include <iostream>
    #include <iterator>
    #include <phasar/PhasarLLVM/ControlFlow/LLVMBasedICFG.h>
    #include <phasar/PhasarLLVM/IfdsIde/FlowFunctions/Gen.h>
    #include <phasar/PhasarLLVM/IfdsIde/FlowFunctions/Identity.h>
    #include <phasar/PhasarLLVM/IfdsIde/FlowFunctions/KillAll.h>
    #include <phasar/PhasarLLVM/IfdsIde/FlowFunctions/LambdaFlow.h>

    using namespace std;
    using namespace psr; // Phasar
    using namespace llvm;

    // CONSTRUCTION, REGISTRATION, DESTRUCTION
    <<construction_destruction>>
    //<<flow_functions>>
    //<<initial_seeds>>
    //<<printing>>
    #+END_SRC

**** Construction, Registration, Destruction
     This section is fairly straightforward. We need to declare
     - A factory function that will call the constructor of the plugin class.
     - Two attributes which will register the plugin into Phasar.

     #+NAME:construction_destruction
     #+BEGIN_SRC c++
       // Factory function that is used to create an instance by the Phasar framework.
       unique_ptr<IFDSTabulationProblemPlugin>
       makeCastCheck(LLVMBasedICFG &I, vector<string> EntryPoints) {
	   return unique_ptr<IFDSTabulationProblemPlugin>(
	   new CastCheck(I, EntryPoints));
       }

       // Is executed on plug-in load and has to register this plug-in to Phasar.
       __attribute__((constructor)) void init() {
	  cout << "init - Cast check plugin\n";
	  IFDSTabulationProblemPluginFactory["ifds_testplugin"] = &makeCastCheck;
       }

       // Is executed on unload, can be used to unregister the plug-in.
       __attribute__((destructor)) void fini() { cout << "fini - Cast check plugin\n"; }

       // Default constructor
       CastCheck::CastCheck(LLVMBasedICFG &I, vector<string> EntryPoints)
	  : IFDSTabulationProblemPlugin(I, EntryPoints), TaintedValues() {}
     #+END_SRC

**** Flow functions

***** Normal flow function
      I think this flow function is for LLVM instructions of type:
      - alloca
      - load
      - store
      - arithmetic

      For allocations there is no issue, but stores are dangerous,
      if I store a tainted value inside another variables, then is
      becomes tainted as well:

      #+BEGIN_SRC c++
      #+END_SRC
**** Initial seeds

**** Printing

* Appendix

** Config file syntax
   For showing how to run an analysis, we will use our gObject simple example.

   #+BEGIN_SRC conf :tangle gobject-example.ll.conf
   module=../../test/gobject-example/gobject-example.ll
   data-flow-analysis=Plugin
   analysis-plugin=./CastCheck.so
   #+END_SRC

** Makefile
   Here is the content of the makefile, to build the plugin
   #+BEGIN_SRC makefile :tangle Makefile
GLIB_INSTALL_PREFIX ?= /usr/
LLVM_INSTALL_PREFIX ?= /home/noric/Dev/wasp-project-course/wasp-program-analysis/llvm/llvm_install/bin
CXX := clang++
CC := clang
CXX_FLAGS := -std=c++14
CXX_FLAGS += -Wall
CXX_FLAGS += -Wno-return-type-c-linkage
CXX_FLAGS += -O0
CXX_FLAGS += -fPIC
CXX_FLAGS += -shared
CXX_FLAGS += -g
INCLUDE_DIRS ?= -I/include/wise_enum/
LLVM_FLAGS := `$(LLVM_INSTALL_PREFIX)/llvm-config --cppflags`

IFDSPluginSrc := CastCheck.cxx
IFDSPlugin := $(patsubst %.cxx,%.so,$(IFDSPluginSrc))

all: run
castcheck: CastCheck.cxx CastCheck.h
	$(CXX) $(CXX_FLAGS) $(INCLUDE_DIRS) $(LLVM_FLAGS) $(IFDSPluginSrc) -o $(IFDSPlugin)

clean:
	rm -f $(IFDSPlugin)
	rm -f *.dot
	rm -f *.json

run: gobject-example.ll.conf castcheck
	phasar --config gobject-example.c.ll.conf
   #+END_SRC
